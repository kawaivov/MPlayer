# Звіт з Практичної роботи №6

**Тема:** Встановлення Docker, контейнеризація застосунку, Docker Compose  
**Студент:** Воробей Володимир  
**Група:** ІПЗс-21

---

## 1. Встановлення та перевірка Docker (60 балів)

Було встановлено **Docker Desktop**. Перевірка працездатності виконана за допомогою офіційного образу `hello-world`.

**Команда:**

```bash
docker run hello-world
```

**Результат:** Docker успішно завантажив тестовий образ і вивів повідомлення про успішну інсталяцію.

---

## 2. Контейнеризація застосунку (75–89 балів)

Для проєкту **"Music Player"** було створено файли `Dockerfile` та `.dockerignore`.

### Основні налаштування Dockerfile:

* **Base Image:** `python:3.10-slim` — оптимізований Linux-образ з Python.
* **Dependencies:** Встановлюються з файлу `requirements.txt`.
* **Server:** Використовується `gunicorn` як WSGI-сервер для продуктивного середовища (замість тестового сервера Flask).
* **Ports:** Експонується порт **8080**.

### Вміст `.dockerignore`:

Ігноруються:

* віртуальне оточення (`venv`),
* кеш (`__pycache__`),
* Git-файли,
* локальна база даних,

що дозволяє зменшити розмір образу та уникнути зайвих файлів у контейнері.

---

## 3. Оркестрація сервісів (90–100 балів)

Для запуску повноцінної архітектури було створено файл `docker-compose.yml`, який об'єднує **три сервіси**.

### Архітектура системи:

#### Сервіс `web` (Nginx):

* Працює на порту **3000**.
* Виступає як **Reverse Proxy**.
* Приймає запити від користувача та перенаправляє їх на API.
* Конфігурація монтується з файлу `nginx/nginx.conf`.

#### Сервіс `api` (Backend):

* Власний застосунок на **Flask**.
* Працює всередині Docker-мережі на порту **8080**.
* Підключений до томів (**volumes**) для збереження музики та обкладинок навіть після перезапуску контейнера.

#### Сервіс `db` (Database):

* Використовується образ `postgres:15-alpine`.
* Забезпечує виконання вимог щодо наявності бази даних у `docker-compose`.

---

## 4. Запуск та тестування

### Команди для запуску:

```bash
# Побудова образів та запуск у фоновому режимі
docker compose up -d --build

# Ініціалізація бази даних (оскільки gunicorn не запускає __main__)
docker exec -it music_api python -c "from app import init_db; init_db()"
```

### Результати перевірки:

* Команда `docker ps` показує **три активні контейнери**:

  * `music_web`
  * `music_api`
  * `music_db`
* Веб-інтерфейс доступний за адресою: **[http://localhost:3000](http://localhost:3000)**.
* API доступне за адресою: **[http://localhost:8080/songs](http://localhost:8080/songs)** (або через проксі).

---

## 4. Зупинка системи

Для коректної зупинки та видалення контейнерів використовується команда:

```bash
docker compose down
```

---

## Висновки

У ході роботи монолітний застосунок було успішно контейнеризовано. Реалізовано мікросервісну архітектуру, у якій веб-сервер (**Nginx**) відокремлений від бізнес-логіки (**Python/Flask**) та бази даних (**PostgreSQL**). Проєкт готовий до розгортання на будь-якому сервері за допомогою однієї команди Docker Compose.
